根据文档内容，您需要使用 Modbus RTU 协议通过 RS485 与控制器通信。以下是对您问题的详细解答：

一、读取温度的 C# 发送命令
核心步骤是构建一个符合 Modbus RTU 格式的请求帧，用于读取保持寄存器。

1. 协议与格式确认：

协议： Modbus RTU
从站地址 (Slave ID): 默认为 0（根据文档 1.1 节：“通讯地址：ADD=0”）
功能码： 0x03 (读取保持寄存器)
寄存器地址： 0x0000 (温度 PV，即第1路温度的实际值，参考文档“三、通讯地址参数表”第一行)
寄存器数量： 0x0001 (读取1个寄存器，即2字节的温度值)
串口参数： 38400, 8, 1, 偶校验
2. 命令帧构建：
一个完整的 Modbus RTU 请求帧包含：[从站地址] [功能码] [起始地址高8位] [起始地址低8位] [寄存器数量高8位] [寄存器数量低8位] [CRC低8位] [CRC高8位]。

根据文档“3 读温度实际值”的例子：
明文指令 00030000000185DB 转换为字节数组即为：0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x85, 0xDB

3. C# 代码示例 (使用串口)：
您可以通过 System.IO.Ports.SerialPort 发送上述字节数组。

using System.IO.Ports;

// 配置串口
SerialPort port = new SerialPort("COM3", 38400, Parity.Even, 8, StopBits.One);
port.Open();

// 构建读取温度的 Modbus RTU 请求帧
byte[] requestFrame = new byte[] { 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x85, 0xDB };

// 发送请求
port.Write(requestFrame, 0, requestFrame.Length);

// ... 等待并接收回复数据 ...
byte[] response = new byte[7]; // 标准回复长度：地址(1)+功能码(1)+字节计数(1)+数据(2)+CRC(2)=7字节
int bytesRead = port.Read(response, 0, response.Length);
port.Close();

// 解析回复（例如回复：00 03 02 0A 37 C2 F2）
if (bytesRead >= 7 && response[0] == 0x00 && response[1] == 0x03)
{
    int byteCount = response[2]; // 应为 0x02，表示后面跟了2个数据字节
    ushort rawValue = (ushort)((response[3] << 8) | response[4](@ref); // 合并高字节和低字节 -> 0x0A37
    double temperature = rawValue / 100.0; // 转换为实际温度值 0x0A37 = 2615 -> 26.15°C
    Console.WriteLine($"温度: {temperature:F2} °C");
}
注意： 更健壮的做法是使用现成的 Modbus 库（如 NModbus），它们会简化帧的构建和 CRC 计算。

二、针对您的问题的逐个解释
1. 从站地址配置问题
现状与可能的问题： 文档明确指出默认通讯地址 ADD=0，因此 SlaveId 默认为 0 是正确的。问题可能出在设备实际地址被修改过，而代码未同步。
解决方案： 确认您的物理设备上设置的 Modbus 从站地址。如果它被改为了其他值（如 1），那么代码中所有请求帧的第一个字节（从站地址）都必须相应修改。例如，若地址为 1，则读取温度的请求帧应为：0x01, 0x03, 0x00, 0x00, 0x00, 0x01, [CRC]。
2. 寄存器地址可能不正确
现状与可能的问题： 当前代码使用 0x0000 读取温度（第1路）。根据文档中“三、通讯地址参数表”，这是读取第1路温度实际值（PV） 的正确地址。
需要明确：
如果您需要读取温度设定值（SV），应使用地址 0x0001。
如果您需要读取第2、3、4路温度，应分别使用地址 0x0036, 0x0037, 0x0043（文档中有对应项）。
请根据您的具体需求确认要读取的变量所对应的寄存器地址。
3. 数据解析问题
现状与可能的问题： 当前代码假设 rawValue / 100.0 是完全正确的。文档“3 读温度实际值”的例子证实了这一点：回复 0A 37（十六进制 0x0A37 = 十进制 2615），2615 / 100 = 26.15 °C。
关键点： 您的解析系数100是正确的。 请务必先将接收到的两个数据字节正确组合成一个16位无符号整数（ushort）后再进行除法运算。此外，文档也说明了负数温度的表示方法（如设定-10.0度为 65536 - 100 = 65436 = 0xFF9C），读取时如果遇到大数值（如 > 32767）可能需要考虑转换为有符号数或进行类似处理，但 PV 值通常为正，按无符号数处理再除以100即可。
4. CRC校验可能存在问题
现状与可能的问题： Modbus RTU 的 CRC 校验至关重要。如果CRC错误，设备不会回复有效数据。
解决方案：
计算： 确保您的 CRC 计算函数是正确的。Modbus RTU 使用 CRC-16 (0xA001 多项式)，初始值为 0xFFFF。请使用标准库或经过验证的算法。在 C# 中，您可以参考或使用 NModbus 库中的 CRC 计算函数。
字节顺序： Modbus RTU 帧中，CRC 的低字节在前，高字节在后（小端序）。在您构建的请求帧 00 03 00 00 00 01 85 DB 中，85 是 CRC 低字节，DB 是高字节。您的 CRC 计算函数输出结果后，需要交换高、低字节顺序再放入帧中。
验证： 同样，接收到设备回复后，您应该计算收到数据的 CRC（除最后两个CRC字节外），并与接收到的 CRC 进行比对，确保数据在传输过程中没有错误。
总结与建议：

首先确保物理连接和串口参数（38400, 8, 1, 偶校验）与文档一致，COM口 7脚(+)、8脚(-)接线正确。
使用调试工具（如 Modbus Poll、串口助手等）先验证您是否能与设备正常通信。用工具发送标准命令（如 00 03 00 00 00 01 85 DB），看是否能收到正确回复。这可以快速隔离是代码问题还是配置/连接问题。
在C#代码中，优先考虑使用成熟的 Modbus 库（如 NModbus），它们封装了协议细节、CRC计算和解析，能极大降低开发难度和出错概率。
如果设备地址不是 0，请务必在代码中修改所有请求的从站地址字节。